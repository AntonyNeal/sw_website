#!/usr/bin/env node

import { Server } from '@modelcontextprotocol/sdk/server/index.js';
import { StdioServerTransport } from '@modelcontextprotocol/sdk/server/stdio.js';
import { CallToolRequestSchema, ListToolsRequestSchema } from '@modelcontextprotocol/sdk/types.js';
import * as dotenv from 'dotenv';
import { readFile, writeFile, readdir } from 'fs/promises';
import { join, dirname } from 'path';
import { fileURLToPath } from 'url';

dotenv.config();

const __filename = fileURLToPath(import.meta.url);
const __dirname = dirname(__filename);
const PROJECT_ROOT = join(__dirname, '..');

// Create MCP server
const server = new Server(
  {
    name: 'webapp-builder-mcp-server',
    version: '1.0.0',
  },
  {
    capabilities: {
      tools: {},
    },
  }
);

// Helper: Read project file
async function readProjectFile(relativePath) {
  try {
    const fullPath = join(PROJECT_ROOT, relativePath);
    const content = await readFile(fullPath, 'utf-8');
    return { success: true, content, path: fullPath };
  } catch (error) {
    return { success: false, error: error.message, path: relativePath };
  }
}

// Helper: Write project file
async function writeProjectFile(relativePath, content) {
  try {
    const fullPath = join(PROJECT_ROOT, relativePath);
    await writeFile(fullPath, content, 'utf-8');
    return { success: true, path: fullPath };
  } catch (error) {
    return { success: false, error: error.message, path: relativePath };
  }
}

// Helper: List directory contents
async function listDirectory(relativePath) {
  try {
    const fullPath = join(PROJECT_ROOT, relativePath);
    const entries = await readdir(fullPath, { withFileTypes: true });
    return {
      success: true,
      entries: entries.map(e => ({
        name: e.name,
        isDirectory: e.isDirectory(),
        isFile: e.isFile(),
      })),
    };
  } catch (error) {
    return { success: false, error: error.message };
  }
}

// Helper: Generate React component template
function generateReactComponent(name, type = 'functional') {
  return `/**
 * ${name} Component
 * Generated by WebApp Builder MCP
 */

import React from 'react';

interface ${name}Props {
  className?: string;
}

export default function ${name}({ className = '' }: ${name}Props) {
  return (
    <div className={\`${name.toLowerCase()} \${className}\`}>
      <h2>${name}</h2>
      {/* Add your component content here */}
    </div>
  );
}
`;
}

// Helper: Generate API route template
function generateApiRoute(resourceName) {
  return `/**
 * ${resourceName} Routes
 * Generated by WebApp Builder MCP
 */

const express = require('express');
const router = express.Router();

/**
 * GET /api/${resourceName.toLowerCase()}
 * Get all ${resourceName.toLowerCase()}
 */
router.get('/', async (req, res) => {
  try {
    // TODO: Implement get all ${resourceName.toLowerCase()}
    res.json({ message: 'Get all ${resourceName.toLowerCase()}' });
  } catch (error) {
    console.error('Error getting ${resourceName.toLowerCase()}:', error);
    res.status(500).json({ error: error.message });
  }
});

/**
 * GET /api/${resourceName.toLowerCase()}/:id
 * Get ${resourceName.toLowerCase()} by ID
 */
router.get('/:id', async (req, res) => {
  try {
    const { id } = req.params;
    // TODO: Implement get ${resourceName.toLowerCase()} by ID
    res.json({ message: \`Get ${resourceName.toLowerCase()} \${id}\` });
  } catch (error) {
    console.error('Error getting ${resourceName.toLowerCase()}:', error);
    res.status(500).json({ error: error.message });
  }
});

/**
 * POST /api/${resourceName.toLowerCase()}
 * Create new ${resourceName.toLowerCase()}
 */
router.post('/', async (req, res) => {
  try {
    const data = req.body;
    // TODO: Implement create ${resourceName.toLowerCase()}
    res.status(201).json({ message: 'Create ${resourceName.toLowerCase()}', data });
  } catch (error) {
    console.error('Error creating ${resourceName.toLowerCase()}:', error);
    res.status(500).json({ error: error.message });
  }
});

/**
 * PUT /api/${resourceName.toLowerCase()}/:id
 * Update ${resourceName.toLowerCase()}
 */
router.put('/:id', async (req, res) => {
  try {
    const { id } = req.params;
    const data = req.body;
    // TODO: Implement update ${resourceName.toLowerCase()}
    res.json({ message: \`Update ${resourceName.toLowerCase()} \${id}\`, data });
  } catch (error) {
    console.error('Error updating ${resourceName.toLowerCase()}:', error);
    res.status(500).json({ error: error.message });
  }
});

/**
 * DELETE /api/${resourceName.toLowerCase()}/:id
 * Delete ${resourceName.toLowerCase()}
 */
router.delete('/:id', async (req, res) => {
  try {
    const { id } = req.params;
    // TODO: Implement delete ${resourceName.toLowerCase()}
    res.json({ message: \`Delete ${resourceName.toLowerCase()} \${id}\` });
  } catch (error) {
    console.error('Error deleting ${resourceName.toLowerCase()}:', error);
    res.status(500).json({ error: error.message });
  }
});

module.exports = router;
`;
}

// Helper: Generate SDK data source template
function generateSdkDataSource(resourceName) {
  return `/**
 * ${resourceName} Data Source
 * Generated by WebApp Builder MCP
 */

import type { EnhancedApiClient } from '../enhancedClient';

export interface ${resourceName} {
  id: string | number;
  name: string;
  createdAt: string;
  updatedAt: string;
  // Add your resource properties here
}

export const ${resourceName}DataSource = {
  /**
   * Get all ${resourceName.toLowerCase()}
   */
  async getAll(this: { client: EnhancedApiClient }): Promise<${resourceName}[]> {
    return this.client.get('/${resourceName.toLowerCase()}');
  },

  /**
   * Get ${resourceName.toLowerCase()} by ID
   */
  async getById(
    this: { client: EnhancedApiClient },
    id: string | number
  ): Promise<${resourceName}> {
    return this.client.get(\`/${resourceName.toLowerCase()}/\${id}\`);
  },

  /**
   * Create new ${resourceName.toLowerCase()}
   */
  async create(
    this: { client: EnhancedApiClient },
    data: Omit<${resourceName}, 'id' | 'createdAt' | 'updatedAt'>
  ): Promise<${resourceName}> {
    return this.client.post('/${resourceName.toLowerCase()}', data);
  },

  /**
   * Update ${resourceName.toLowerCase()}
   */
  async update(
    this: { client: EnhancedApiClient },
    id: string | number,
    data: Partial<${resourceName}>
  ): Promise<${resourceName}> {
    return this.client.put(\`/${resourceName.toLowerCase()}/\${id}\`, data);
  },

  /**
   * Delete ${resourceName.toLowerCase()}
   */
  async delete(
    this: { client: EnhancedApiClient },
    id: string | number
  ): Promise<{ success: boolean }> {
    return this.client.delete(\`/${resourceName.toLowerCase()}/\${id}\`);
  },
};
`;
}

// Helper: Generate tenant configuration template
function generateTenantConfig(tenantName, businessName) {
  return `/**
 * ${businessName} Tenant Configuration
 * Generated by WebApp Builder MCP
 */

import type { TenantContent } from '../../core/types/tenant';

export const content: TenantContent = {
  name: '${businessName}',
  tagline: 'Your professional tagline here',
  bio: \`Professional bio and description here.\`,
  
  services: [
    {
      id: 'service-1',
      name: 'Consultation',
      description: 'Professional consultation service',
      duration: '60 minutes',
      price: 150,
      featured: true,
    },
  ],

  contact: {
    email: 'contact@${tenantName}.com',
    phone: '+1 (555) 000-0000',
    social: {
      twitter: '',
      instagram: '',
      linkedin: '',
    },
  },

  booking: {
    minimumNotice: 24,
    cancellationPolicy: 'Cancellations must be made at least 24 hours in advance.',
    depositRequired: false,
    depositAmount: 0,
  },
};

export default content;
`;
}

// Define available tools
server.setRequestHandler(ListToolsRequestSchema, async () => {
  return {
    tools: [
      {
        name: 'read_project_file',
        description: 'Read the contents of any file in the project',
        inputSchema: {
          type: 'object',
          properties: {
            path: {
              type: 'string',
              description: 'Relative path from project root (e.g., "src/components/Button.tsx")',
            },
          },
          required: ['path'],
        },
      },
      {
        name: 'write_project_file',
        description: 'Write or update a file in the project',
        inputSchema: {
          type: 'object',
          properties: {
            path: {
              type: 'string',
              description: 'Relative path from project root',
            },
            content: {
              type: 'string',
              description: 'Full content to write to the file',
            },
          },
          required: ['path', 'content'],
        },
      },
      {
        name: 'list_directory',
        description: 'List contents of a directory in the project',
        inputSchema: {
          type: 'object',
          properties: {
            path: {
              type: 'string',
              description: 'Relative path from project root (e.g., "src/components")',
            },
          },
          required: ['path'],
        },
      },
      {
        name: 'generate_react_component',
        description: 'Generate a new React component with TypeScript',
        inputSchema: {
          type: 'object',
          properties: {
            name: {
              type: 'string',
              description: 'Component name in PascalCase (e.g., "UserProfile")',
            },
            path: {
              type: 'string',
              description: 'Where to create the component (e.g., "src/components")',
            },
          },
          required: ['name', 'path'],
        },
      },
      {
        name: 'generate_api_route',
        description: 'Generate Express API route with CRUD operations',
        inputSchema: {
          type: 'object',
          properties: {
            resourceName: {
              type: 'string',
              description: 'Resource name in PascalCase (e.g., "Product")',
            },
            path: {
              type: 'string',
              description: 'Where to create the route file (e.g., "api/routes")',
            },
          },
          required: ['resourceName', 'path'],
        },
      },
      {
        name: 'generate_sdk_datasource',
        description: 'Generate SDK data source for a new resource',
        inputSchema: {
          type: 'object',
          properties: {
            resourceName: {
              type: 'string',
              description: 'Resource name in PascalCase (e.g., "Product")',
            },
          },
          required: ['resourceName'],
        },
      },
      {
        name: 'generate_tenant_config',
        description: 'Generate a new tenant configuration',
        inputSchema: {
          type: 'object',
          properties: {
            tenantName: {
              type: 'string',
              description: 'Tenant identifier (e.g., "acmecorp")',
            },
            businessName: {
              type: 'string',
              description: 'Business display name (e.g., "Acme Corporation")',
            },
          },
          required: ['tenantName', 'businessName'],
        },
      },
      {
        name: 'analyze_project_structure',
        description: 'Get overview of project structure and key files',
        inputSchema: {
          type: 'object',
          properties: {},
        },
      },
      {
        name: 'get_simplybook_config',
        description: 'Get current SimplyBook.me integration configuration',
        inputSchema: {
          type: 'object',
          properties: {},
        },
      },
      {
        name: 'get_tenant_list',
        description: 'List all configured tenants in the project',
        inputSchema: {
          type: 'object',
          properties: {},
        },
      },
    ],
  };
});
            app_id: {
              type: 'string',
              description: 'The ID of the app to retrieve',
            },
          },
          required: ['app_id'],
        },
      },
      {
        name: 'list_databases',
        description: 'List all managed databases in your DigitalOcean account',
        inputSchema: {
          type: 'object',
          properties: {},
        },
      },
      {
        name: 'get_database',
        description: 'Get details for a specific database cluster',
        inputSchema: {
          type: 'object',
          properties: {
            database_id: {
              type: 'string',
              description: 'The ID of the database cluster',
            },
          },
          required: ['database_id'],
        },
      },
      {
        name: 'list_functions_namespaces',
        description: 'List all DigitalOcean Functions namespaces',
        inputSchema: {
          type: 'object',
          properties: {},
        },
      },
      {
        name: 'list_domains',
        description: 'List all domains in your DigitalOcean account',
        inputSchema: {
          type: 'object',
          properties: {},
        },
      },
      {
        name: 'get_account',
        description: 'Get your DigitalOcean account information',
        inputSchema: {
          type: 'object',
          properties: {},
        },
      },
      {
        name: 'list_droplets',
        description: 'List all Droplets (VMs) in your account',
        inputSchema: {
          type: 'object',
          properties: {},
        },
      },
      {
        name: 'get_droplet',
        description: 'Get details for a specific Droplet',
        inputSchema: {
          type: 'object',
          properties: {
            droplet_id: {
              type: 'string',
              description: 'The ID of the Droplet',
            },
          },
          required: ['droplet_id'],
        },
      },
      {
        name: 'add_ssh_key',
        description: 'Add an SSH public key to your DigitalOcean account',
        inputSchema: {
          type: 'object',
          properties: {
            name: {
              type: 'string',
              description: 'The name to identify this SSH key',
            },
            public_key: {
              type: 'string',
              description: 'The full SSH public key string',
            },
          },
          required: ['name', 'public_key'],
        },
      },
      {
        name: 'list_ssh_keys',
        description: 'List all SSH keys in your DigitalOcean account',
        inputSchema: {
          type: 'object',
          properties: {},
        },
      },
    ],
  };
});

// Handle tool execution
server.setRequestHandler(CallToolRequestSchema, async (request) => {
  const { name, arguments: args } = request.params;

  try {
    let result;

    switch (name) {
      case 'read_project_file': {
        result = await readProjectFile(args.path);
        break;
      }

      case 'write_project_file': {
        result = await writeProjectFile(args.path, args.content);
        break;
      }

      case 'list_directory': {
        result = await listDirectory(args.path);
        break;
      }

      case 'generate_react_component': {
        const componentContent = generateReactComponent(args.name);
        const filePath = `${args.path}/${args.name}.tsx`;
        result = await writeProjectFile(filePath, componentContent);
        result.generated = true;
        result.componentName = args.name;
        break;
      }

      case 'generate_api_route': {
        const routeContent = generateApiRoute(args.resourceName);
        const filePath = `${args.path}/${args.resourceName.toLowerCase()}.routes.js`;
        result = await writeProjectFile(filePath, routeContent);
        result.generated = true;
        result.resourceName = args.resourceName;
        break;
      }

      case 'generate_sdk_datasource': {
        const dataSourceContent = generateSdkDataSource(args.resourceName);
        const filePath = `sdk/src/datasources/${args.resourceName.toLowerCase()}.ts`;
        result = await writeProjectFile(filePath, dataSourceContent);
        result.generated = true;
        result.resourceName = args.resourceName;
        break;
      }

      case 'generate_tenant_config': {
        const configContent = generateTenantConfig(args.tenantName, args.businessName);
        const filePath = `src/tenants/${args.tenantName}/content.config.ts`;
        result = await writeProjectFile(filePath, configContent);
        result.generated = true;
        result.tenantName = args.tenantName;
        break;
      }

      case 'analyze_project_structure': {
        const structure = {};
        
        // Read key directories
        const srcDir = await listDirectory('src');
        const apiDir = await listDirectory('api');
        const sdkDir = await listDirectory('sdk/src');
        
        structure.src = srcDir.success ? srcDir.entries : [];
        structure.api = apiDir.success ? apiDir.entries : [];
        structure.sdk = sdkDir.success ? sdkDir.entries : [];
        
        // Read package.json
        const pkg = await readProjectFile('package.json');
        if (pkg.success) {
          structure.packageInfo = JSON.parse(pkg.content);
        }
        
        result = structure;
        break;
      }

      case 'get_simplybook_config': {
        const envExample = await readProjectFile('.env.example');
        const apiService = await readProjectFile('api/services/simplybook.service.js');
        
        result = {
          envExample: envExample.success ? envExample.content : null,
          serviceFile: apiService.success ? 'Found' : 'Not found',
          configKeys: [
            'SIMPLYBOOK_API_KEY',
            'SIMPLYBOOK_SECRET_KEY',
            'SIMPLYBOOK_COMPANY',
            'SIMPLYBOOK_JSON_RPC_URL',
          ],
        };
        break;
      }

      case 'get_tenant_list': {
        const tenantsDir = await listDirectory('src/tenants');
        
        if (tenantsDir.success) {
          const tenants = tenantsDir.entries
            .filter(e => e.isDirectory)
            .map(e => e.name);
          
          result = {
            tenants,
            count: tenants.length,
          };
        } else {
          result = { tenants: [], count: 0, error: tenantsDir.error };
        }
        break;
      }

      default:
        throw new Error(`Unknown tool: ${name}`);
    }

    return {
      content: [
        {
          type: 'text',
          text: JSON.stringify(result, null, 2),
        },
      ],
    };
  } catch (error) {
    return {
      content: [
        {
          type: 'text',
          text: `Error: ${error.message}`,
        },
      ],
      isError: true,
    };
  }
});

// Start the server
async function main() {
  const transport = new StdioServerTransport();
  await server.connect(transport);
  console.error('WebApp Builder MCP Server running on stdio');
}

main().catch((error) => {
  console.error('Fatal error:', error);
  process.exit(1);
});
